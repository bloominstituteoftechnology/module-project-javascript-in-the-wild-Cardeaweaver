<!DOCTYPE html>
<html lang="en">

<head>
  <title>JavaScript in the Wild</title>
</head>

<body>
  <h1>JavaScript in the Wild</h1>
  <p>Please load this file in VSCode and Chrome, and open the Console in Chrome Dev Tools.</p>
  <p>Work through the challenges found inside the script tag in this document,
    until the Console reports all tests passing.</p>

  <script>
    // In CHALLENGES 1-7, you will fill in some functions.

    // To do this, translate each ğŸ§  set of instructions into a working function.
    // â— Functions are already scaffolded as arrow functions.
    // â— You must add the parameters to the function that you need
    // â— Watch the Guided Project to learn proper debugging technique.

    // ğŸ‘‰ CHALLENGE 1
    // ğŸ§  The function swapper takes an array and swaps its first and last elements.
    // ğŸ§  If the array has fewer than two elements the function returns the string "No swap performed".
    // ğŸ§  Examples of usage:
    // swapper(['a', 'b']) // should return ['b', 'a']
    // swapper(['a', 'b', 'c']) // should return ['c', 'b', 'a']
    // swapper(['a']) // should return "No swap performed"
    // â— Notes
    // ğŸ§  Try using destructuring to grab a reference to the first element of the array
    // ğŸ§  Try using the at method of arrays to grab the last element
    function swapper(array) {
    if (array.length < 2) {
        return "No swap performed";
    } else {
        let temp = array[0];
        array[0] = array[array.length - 1];
        array[array.length - 1] = temp;
        return array;
    }
}

// Test 
console.log(swapper(['a', 'b']));      // ['b', 'a']
console.log(swapper(['a', 'b', 'c'])); // ['c', 'b', 'a']
console.log(swapper(['a']));           // "No swap performed"

    // ğŸ‘‰ CHALLENGE 2
    // ğŸ§  The function headAndTail takes an array as its argument.
    // ğŸ§  It returns a new array with two elements.
    // ğŸ§  The first element is the head of the original array.
    // ğŸ§  The second element is the tail of the original array.
    // ğŸ§  If the given array is empty, return the string "This array is empty"
    // ğŸ§  Examples of usage:
    // headAndTail([1, 2, 3]) // should return [1, [2, 3]]
    // â— Notes
    // ğŸ§  Try using destructuring and the spread operator to get the head and tail.
    // ğŸ§  Try using the ternary operator instead of a conditional statement when deciding what to return.
    // ğŸ§  So instead of doing `if ('foo') return 'bar' else return 'baz'` do `return 'foo' ? 'bar' : 'baz'`
    // ğŸ§  The above recommendations allow to write the whole function body in just two clean lines!
    
// Function to get the head and tail of an array
const headAndTail = (arr) => {
  // If the array is empty, return "This array is empty"
  return arr.length === 0 ? "This array is empty" : [arr[0], arr.slice(1)];
}

// Test 
console.log(headAndTail([1, 2, 3])); //  [1, [2, 3]]
    

    // ğŸ‘‰ CHALLENGE 3
    // ğŸ§  The function devGreet takes an isFrontend Boolean, and an isHappy Boolean, as arguments.
    // ğŸ§  Examples of usage:
    // devGreet(true, true) // should return "Hey, I am a frontend dev and I am happy"
    // devGreet(true, false) // should return "Hey, I am a frontend dev and I am sad"
    // devGreet(false, true) // should return "Hey, I am a backend dev and I am happy"
    // devGreet(false, false) // should return "Hey, I am a backend dev and I am sad"
    // â— Notes
    // ğŸ§  Use ternary expressions to construct the string.
 
// Function to greet developers based on their role and mood
const devGreet = (isFrontend, isHappy) => {
  // Construct the greeting string using ternary expressions
  return `Hey, I am a ${isFrontend ? 'frontend' : 'backend'} dev and I am ${isHappy ? 'happy' : 'sad'}`;
}

// Test cases
console.log(devGreet(true, true)); // Output: "Hey, I am a frontend dev and I am happy"
console.log(devGreet(true, false)); // Output: "Hey, I am a frontend dev and I am sad"
console.log(devGreet(false, true)); // Output: "Hey, I am a backend dev and I am happy"
console.log(devGreet(false, false)); // Output: "Hey, I am a backend dev and I am sad"

    

    // ğŸ‘‰ CHALLENGE 4
    // ğŸ§  The function recognize takes an object representing a user.
    // ğŸ§  If the object has a name property, return a string in the format "<name> Rules!".
    // ğŸ§  If there is no name prop, return the string "Hidden Person Rocks!"
    // ğŸ§  Examples of usage:
    // recognize({ name: 'Katherine Johnson' }) // should return "Katherine Johnson Rules!"
    // recognize({}) // should return "Hidden Person Rocks!"
    // â— Notes
    // ğŸ§  Try using destructuring to grab the name, and a return followed by a ternary expression.
    function recognize(user) {
      const { name } = user;
    return name ? `${name} Rules!` : "Hidden Person Rocks!";
}

// Test cases
console.log(recognize({ name: 'Katherine Johnson' })); // Output: "Katherine Johnson Rules!"
console.log(recognize({})); // Output: "Hidden Person Rocks!"

    // ğŸ‘‰ CHALLENGE 5
    // ğŸ§  The function processBooleans takes an array of Booleans represented using integers (1/0 instead of true/false)
    // ğŸ§  It should return a new array containing strings ("Y"/"N")
    // ğŸ§  Example of usage:
    // processBooleans([1, 0, 0, 1, 0]) // should return ["Y", "N", "N", "Y", "N"]
    // â— Notes
    // ğŸ§  Using map, arrow function syntax, and the ternary, you can make this function a short one-liner
    const processBooleans = (boolArray) => {
      return boolArray.map(bool => bool ? "Y" : "N");
}

// Test 
console.log(processBooleans([1, 0, 0, 1, 0])); // ["Y", "N", "N", "Y", "N"]
    

    // ğŸ‘‰ CHALLENGE 6
    // ğŸ§  The function reverseString takes a string as its argument, and returns it reversed.
    // ğŸ§  If the string is a palindrome though, return the string "It's a palindrome!"
    // ğŸ§  Examples of usage:
    // reverseString('Hello, World') // should return "dlroW ,olleH"
    // â— Notes
    // ğŸ§  Research on your own what a palindrome is.
    // ğŸ§  Split the string but do not use the reverse method of arrays. Let's do it manually.
    // ğŸ§  We suggest using a for loop. Research how to loop backwards over an array, starting at the last element.
    // ğŸ§  Use a ternary in the return statement.
    const reverseString = (str) => {
 // Check if the string is a palindrome
 const isPalindrome = str === str.split('').reverse().join('');

// If it's a palindrome, return the appropriate message
if (isPalindrome) {
    return "It's a palindrome!";
}

// Otherwise, reverse the string manually
let reversed = '';
for (let i = str.length - 1; i >= 0; i--) {
    reversed += str[i];
}
return reversed;
}
    

    // ğŸ‘‰ CHALLENGE 7
    // ğŸ§  The function zip receives three arrays as arguments. The three arrays are of the same length (which could be any length).
    // ğŸ§  Array 1 contains names, array 2 contains year numbers, and array 3 contains Booleans.
    // ğŸ§  The zip function returns an array of objects
    // ğŸ§  Each object inside the returned array is constructed combining the information from arrays 1, 2, 3.
    // ğŸ§  Each object has three props: `name`, `born` and `jsLover`.
    // ğŸ§  Examples of usage:
    // zip(['Joe', 'Anna'], [1987, 1955], [true, false])
    //   should return [{ name: 'Joe', born: '1987', jsLover: true }, { name: 'Anna', born: 1955, jsLover: false }]
    // â— Notes
    // ğŸ§  Even though object properties have no particular order, to avoid confusing
    // the test runner, please set in each object first name, then age, and finally jsLover.
    function zip(names, years, jsLovers) {
  // Check if all arrays have the same length
  if (names.length !== years.length || names.length !== jsLovers.length) {
    throw new Error("Arrays must have the same length");
  }

  // Create an empty array to store the resulting objects
  const result = [];

  // Loop through each element index
  for (let i = 0; i < names.length; i++) {
    // Create an object with the corresponding name, year, and jsLover value
    const person = {
      name: names[i],
      born: years[i], // Convert year to string for consistency
      jsLover: jsLovers[i],
    };

    // Add the object to the result array
    result.push(person);
  }

  return result;
}

// Examples of usage:
console.log(zip(['Joe', 'Anna'], [1987, 1955], [true, false]));
// Output: [{ name: 'Joe', born: '1987', jsLover: true }, { name: 'Anna', born: 1955, jsLover: false }]


// Test case
console.log(zip(['Joe', 'Anna'], [1987, 1955], [true, false]));
// Output: [{ name: 'Joe', born: '1987', jsLover: true }, { name: 'Anna', born: '1955', jsLover: false }]

    

    // ğŸ§ª TESTS, do not work below this line
    // ğŸ§ª TESTS, do not work below this line
    // ğŸ§ª TESTS, do not work below this line
    runTests('CHALLENGE 1 - swapper', swapper, [
      [[['a', 'b']], ['b', 'a']],
      [[['a', 'b', 'c']], ['c', 'b', 'a']],
      [[['a', 'b', 'c', 'd']], ['d', 'b', 'c', 'a']],
      [[['a']], "No swap performed"],
      [[[]], "No swap performed"],
    ])
    runTests('CHALLENGE 2 - headAndTail', headAndTail, [
      [[['a', 'b']], ['a', ['b']]],
      [[['a', 'b', 'c']], ['a', ['b', 'c']]],
      [[['a', 'b', 'c', 'd']], ['a', ['b', 'c', 'd']]],
      [[['a']], ['a', []]],
      [[[]], "This array is empty"],
    ])
    runTests('CHALLENGE 3 - devGreet', devGreet, [
      [[true, true], "Hey, I am a frontend dev and I am happy"],
      [[true, false], "Hey, I am a frontend dev and I am sad"],
      [[false, true], "Hey, I am a backend dev and I am happy"],
      [[false, false], "Hey, I am a backend dev and I am sad"],
    ])
    runTests('CHALLENGE 4 - recognize', recognize, [
      [[{ name: 'Katherine Johnson' }], "Katherine Johnson Rules!"],
      [[{ name: 'Gertrude Elion', born: 1918 }], "Gertrude Elion Rules!"],
      [[{ nobelPrize: 1986 }], "Hidden Person Rocks!"],
    ])
    runTests('CHALLENGE 5 - processBooleans', processBooleans, [
      [[[1, 0, 0, 1, 0, 1]], ["Y", "N", "N", "Y", "N", "Y"]],
      [[[0, 1, 0, 1, 1]], ["N", "Y", "N", "Y", "Y"]],
      [[[]], []],
    ])
    runTests('CHALLENGE 6 - reverseString', reverseString, [
      [['Hello, World'], 'dlroW ,olleH'],
      [['Personal Access Token'], 'nekoT sseccA lanosreP'],
      [['tesla'], 'alset'],
      [['rotator'], "It's a palindrome!"],
      [['tenet'], "It's a palindrome!"],
      [['axa'], "It's a palindrome!"],
    ])
    const unzipped1 = [['Alla', 'Josh', 'Byron'], [1995, 1988, 1996], [true, true, false]]
    const zipped1 = [
      { name: 'Alla', born: 1995, jsLover: true },
      { name: 'Josh', born: 1988, jsLover: true },
      { name: 'Byron', born: 1996, jsLover: false },
    ]
    const unzipped2 = [['Joe', 'Anna'], [1987, 1955], [true, false]]
    const zipped2 = [
      { name: 'Joe', born: 1987, jsLover: true },
      { name: 'Anna', born: 1955, jsLover: false },
    ]
    runTests('CHALLENGE 7 - zip', zip, [
      [unzipped1, zipped1],
      [unzipped2, zipped2],
    ])
    function runTests(testName, func, tests) {
      let results = []
      tests.forEach(test => {
        const argsList = test[0]
        const expected = JSON.stringify(test[1])
        const actual = JSON.stringify(func.apply(null, JSON.parse(JSON.stringify(argsList))))
        results.push([argsList, expected, actual])
      })
      console.log('\n' + testName)
      if (results.every(result => result[1] === result[2])) console.log('\tâœ… All tests pass')
      else results.forEach((result, idx) => {
        if (result[1] === result[2]) console.log(`\tâœ… Test ${idx + 1} passes`)
        else console.log(`\tâŒ Test ${idx + 1} fails: ${func.name}(${result[0]
          .map(JSON.stringify)}) should return ${result[1]} but returns ${result[2]}`)
      })
    }
  </script>
</body>

</html>
